<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title id="title">Fourier Drawing App</title>
  <style>
    :root {
      --bg-color: #0d1b2a;
      --panel-color: #1b263b;
      --accent-color: #00b4d8;
      --text-color: #ffffff;
      --btn-color: #415a77;
      --btn-hover: #00b4d8;
    }

    body {
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .container {
      display: flex;
      flex-direction: row;
      gap: 2rem;
      width: 100%;
      max-width: 100vw;
      flex-wrap: wrap;
      justify-content: center;
    }

    .main-canvas-container {
      flex: 1 1 auto;
      max-width: min(90vw, 90vh);
      aspect-ratio: 1 / 1;
      position: relative;
    }

    #mainCanvas {
      width: 100%;
      height: 100%;
      background-color: black;
      touch-action: none;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-width: 300px;
      flex: 1 1 auto;
      overflow:hidden;
    }

    .mini-canvases {
      display: flex;
      flex-direction: row;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .mini-canvases canvas {
      width: 45%;
      aspect-ratio: 1 / 1;
      background-color: #000;
    }

    button {
      background-color: var(--btn-color);
      color: white;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.3s;
    }

    button:hover {
      background-color: var(--btn-hover);
    }

    button.Press {
      background-color: var(--btn-hover);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
      transform: translateY(2px);
    }

    .brush-preview {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-top: 0.5rem;
      align-self: center;
    }

    input[type="range"] {
      width: 100%;
      margin: 0.5rem 0;
      background-color: #415a77;
      border-radius: 8px;
      height: 8px;
      cursor: pointer;
    }

    @media (orientation: landscape) {
      .sidebar {
        height: 100%;
        max-height: min(90vw, 90vh); /* 跟主畫布一樣高 */
        overflow-y: auto;
      }
    }

    .fullscreen-canvas-container {
      position: fixed; /* 確保容器位於最上層 */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5); /* 可選的背景遮罩 */
      display: flex;
      justify-content: center; /* 水平居中 */
      align-items: center; /* 垂直居中 */
      z-index: 1000; /* 確保在其他元素之上 */
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; /* 平滑過渡效果 */
    }

    .fullscreen-canvas-container.active {
      opacity: 1;
      visibility: visible;
      transition: opacity 0.3s ease-in-out;
    }

    .fullscreen-canvas {
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* 可選的陰影效果 */
      background-color: black;
    }

    .towButtonInOneLine {
      display: flex;
      gap: 5px;
      justify-content: space-between;
    }

    .towButtonInOneLine button
    {width:calc(50% - 5px);}

    .threeButtonInOneLine {
      display: flex;
      gap: 5px;
      justify-content: space-between;
    }

    .threeButtonInOneLine button
    {width:calc(33.33% - 5px);}
  </style>
  <script src="https://turbomaze.github.io/JS-Fourier-Image-Analysis/js/fourier.js"></script>
</head>
<body>
  <div class="container">
    <div class="main-canvas-container">
      <canvas width=256 height=256 id="mainCanvas"></canvas>
    </div>
    <div class="sidebar">
      <div class="mini-canvases">
        <canvas width=256 height=256 class="tap2show" id="originalCV"></canvas>
        <canvas width=256 height=256 class="tap2show" id="fftCV"></canvas>
        <canvas width=256 height=256 class="tap2show" id="maskCV"></canvas>
        <canvas width=256 height=256 class="tap2show" id="resultCV"></canvas>
      </div>
      <div class="towButtonInOneLine">
        <button onclick="copy2original()">設為原圖</button>
        <button onclick="importOriginal()">匯入原圖</button>
      </div>
      <div class="towButtonInOneLine">
        <button onclick="copy2mask()">設為遮罩</button>
        <button onclick="importMask()">匯入遮罩</button>
      </div>
      <div class="towButtonInOneLine">
        <button id="showFFTinCanvas" onclick="showFFTinCanvas()">頻域預覽</button>
        <button id="doubleModeSwitch" onclick="doubleModeSwitch()">增強模式</button>
      </div>
      <div class="threeButtonInOneLine">
      <button onclick="fillCanvas('white')">填白色</button>
      <button onclick="fillCanvas('#888')">填灰色</button>
      <button onclick="fillCanvas('black')">填黑色</button>
      </div>
      <div class="threeButtonInOneLine">
      <button onclick="setPenColor('black')">黑筆</button>
      <button onclick="setPenColor('#888')">灰筆</button>
      <button onclick="setPenColor('white')">白筆</button>
      </div>
      <div>
        <label for="brushSizeRange"
               style="color: var(--text-color);">筆刷大小:</label>
        <input type="range"
               id="brushSizeRange"
               oninput="updateBrushSize(this.value)"
               min="1" max="50" value="5" step="1" >
        <div class="brush-preview" id="brushPreview"></div>
      </div>
    </div>
  </div>

  <script> //點擊放大顯示三個小canvas
    document.addEventListener('DOMContentLoaded', function() {
      const canvases = document.querySelectorAll('.tap2show');
      const miniCanvasesContainer = document.querySelector('.mini-canvases');
      let fullscreenContainer = null;
      let activeCanvas = null;
      canvases.forEach(canvas => {
        canvas.addEventListener('click', function() {
          activeCanvas = this;
          showFullscreenCanvas(this);
        });
      });
      function showFullscreenCanvas(canvas) {
        if (!fullscreenContainer) {
          fullscreenContainer = document.createElement('div');
          fullscreenContainer.classList.add('fullscreen-canvas-container');
          document.body.appendChild(fullscreenContainer);
          // 點擊背景關閉放大顯示
          fullscreenContainer.addEventListener('click', function(event) {
            if (event.target === fullscreenContainer)
            {hideFullscreenCanvas();}
          });
        }
        // 清空之前的內容
        fullscreenContainer.innerHTML = '';
        // 複製 canvas 元素並添加到全螢幕容器中
        const fullscreenCanvas = document.createElement('canvas');
        fullscreenCanvas.classList.add('fullscreen-canvas');
        fullscreenCanvas.width=canvas.width;
        fullscreenCanvas.height=canvas.width;
        fullscreenContainer.appendChild(fullscreenCanvas);

          const targetCtx = fullscreenCanvas.getContext('2d');
          const sw = canvas.offsetWidth;
          const sh = canvas.offsetWidth;
          const dw = fullscreenCanvas.offsetWidth;
          const dh = fullscreenCanvas.offsetHeight;
          targetCtx.drawImage(canvas, 0, 0)//, sw, sh, 0, 0, dw, dh);

        // 顯示全螢幕容器
        fullscreenContainer.classList.add('active');
        // 禁用原始容器的點擊事件，避免重複觸發
        if (miniCanvasesContainer)
        {miniCanvasesContainer.style.pointerEvents = 'none';}
      }
      function hideFullscreenCanvas() {
        if (fullscreenContainer) {
          fullscreenContainer.classList.remove('active');
          fullscreenContainer.innerHTML = ''; // 清空內容
          // 重新啟用原始容器的點擊事件
          if (miniCanvasesContainer) {
            miniCanvasesContainer.style.pointerEvents = 'auto';
          }
          activeCanvas = null;
        }
      }
    });
  </script>
  <script> //UI事件


    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    let penColor = 'white';
    let brushSize = 5;

    window.addEventListener('load', () => {
      fillCanvas('black');
      updateBrushPreview();
    });

    function fillCanvas(color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function setPenColor(color) {
      penColor = color;
      updateBrushPreview();
    }

    function updateBrushSize(size) {
      brushSize = size;
      updateBrushPreview();
    }

    function updateBrushPreview() {
      const preview = document.getElementById('brushPreview');
      let Zoom=2*canvas.offsetWidth/canvas.width;
      preview.style.width = `${brushSize * Zoom}px`;
      preview.style.height = `${brushSize * Zoom}px`;
      preview.style.backgroundColor = penColor;
    }

    function draw(x, y) {
      let Zoom=canvas.width/canvas.offsetWidth;
      ctx.beginPath();
      ctx.arc(x*Zoom,y*Zoom, brushSize, 0, Math.PI * 2);
      ctx.fillStyle = penColor;
      ctx.fill();
    }

    // Desktop
    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      draw(e.offsetX, e.offsetY);
    });

    canvas.addEventListener('mousemove', (e) =>
    {if (drawing) draw(e.offsetX, e.offsetY);});

    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseleave', () => drawing = false);

    // Mobile
    canvas.addEventListener('touchstart', (e) => {
      drawing = true;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      draw(touch.clientX - rect.left, touch.clientY - rect.top);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      draw(touch.clientX - rect.left, touch.clientY - rect.top);
    });

    canvas.addEventListener('touchend', () => drawing = false);

    function copyCanvasContent(sourceCanvas, targetCanvas) {
      const targetCtx = targetCanvas.getContext('2d');
      const sw = sourceCanvas.width;
      const sh = sourceCanvas.height;
      const dw = targetCanvas.width;
      const dh = targetCanvas.height;
      targetCtx.drawImage(sourceCanvas, 0, 0, sw, sh, 0, 0, dw, dh);
    }

    function copy2original(){
      let target=document.getElementById('originalCV');
      copyCanvasContent(canvas,target);
      computeFFT();
    }
    function copy2mask(){
      let target=document.getElementById('maskCV');
      copyCanvasContent(canvas,target);
      computeFFT();
    }

    function importOriginal() {
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';

      fileInput.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const originalCanvas = document.getElementById('originalCV');
            if (originalCanvas && originalCanvas.getContext) {
              const ctx = originalCanvas.getContext('2d');
              const img = new Image();
              img.onload = function() {
                // 繪製圖片到 Canvas，您可以根據需要調整圖片在 Canvas 中的位置和大小
                ctx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
                computeFFT(); // 在成功繪製圖片後呼叫 computeFFT()
              };
              img.src = e.target.result;
            } else {
              console.error('找不到 ID 為 originalCV 的 Canvas 元素或其 context。');
            }
          };
          reader.readAsDataURL(file);
        }
      };

      fileInput.click();
    }

    function importMask() {
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';

      fileInput.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const maskCanvas = document.getElementById('maskCV');
            if (maskCanvas && maskCanvas.getContext) {
              const ctx = maskCanvas.getContext('2d');
              const img = new Image();
              img.onload = function() {
                // 繪製圖片到 Canvas，您可以根據需要調整圖片在 Canvas 中的位置和大小
                ctx.drawImage(img, 0, 0, maskCanvas.width, maskCanvas.height);
                computeFFT(); // 在成功繪製圖片後呼叫 computeFFT()
              };
              img.src = e.target.result;
            } else {
              console.error('找不到 ID 為 maskCV 的 Canvas 元素或其 context。');
            }
          };
          reader.readAsDataURL(file);
        }
      };

      fileInput.click();
    }

    function setCanvasAsDivBackground(canvasObj, divObj) {
      const dataURL = canvasObj.toDataURL(); // 將 canvas 轉成 base64 圖片
      divObj.style.backgroundImage = `url(${dataURL})`;
      divObj.style.backgroundSize = "cover"; // 可視情況調整
      divObj.style.backgroundPosition="top center"; /* 靠上對齊，水平置中 */
    }

    function showFFTinCanvas(){
      const btn = document.getElementById("showFFTinCanvas");
      const divObj = document.querySelector(".main-canvas-container");
      const canvasObj = document.querySelector("#fftCV");
      if(btn.className=="Press"){
        btn.className="";
        document.querySelector("#mainCanvas").style.backgroundColor="#00000000";
        document.querySelector("#mainCanvas").style.opacity=1;
      }else{
        btn.className="Press";
        setCanvasAsDivBackground(canvasObj,divObj);
        document.querySelector("#mainCanvas").style.opacity=0.5;
      }
    }
    function doubleModeSwitch(){
      const btn = document.getElementById("doubleModeSwitch");
      if(btn.className=="Press"){
        btn.className="";
        doubleMode=false;
      }else{
        btn.className="Press";
        doubleMode=true;
      }
    }
  </script>
  <script> //計算FFT
    let doubleMode=false;

    function shiftIndex(idx, size = canvas.width) {
      const half = size / 2;
      let row = Math.floor(idx / size);
      let col = idx % size;
      let newRow = row, newCol = col;
      // Determine which quadrant (1~4) this cell belongs to
      const inTop = row < half;
      const inLeft = col < half;
      if ((inTop && inLeft) || (!inTop && !inLeft)) {
        // Quadrant 1 or 4 — flip along "/"
        let localRow = row % half;
        let localCol = col % half;
        newRow = half * (inTop ? 0 : 1) + (half - 1 - localCol);
        newCol = half * (inLeft ? 0 : 1) + (half - 1 - localRow);
      } else {
        // Quadrant 2 or 3 — flip along "\"
        let localRow = row % half;
        let localCol = col % half;
        newRow = half * (inTop ? 0 : 1) + localCol;
        newCol = half * (inLeft ? 0 : 1) + localRow;
      }
      return newRow * size + newCol;
    }

    function putImgInto(imgList,canvas){
      const ctx = canvas.getContext("2d");
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      for (let i = 0; i < imgList.length; i++) {
        imageData.data[i * 4 + 0] = imgList[i];
        imageData.data[i * 4 + 1] = imgList[i];
        imageData.data[i * 4 + 2] = imgList[i];
        imageData.data[i * 4 + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }

    function computeFFT(){
      const originalCV = document.getElementById("originalCV");
      const originalCTX = originalCV.getContext("2d");
      const fftCV = document.getElementById("fftCV");
      const fftCTX = fftCV.getContext("2d");
      const maskCV = document.getElementById("maskCV");
      const maskCTX = maskCV.getContext("2d");
      const resultCV = document.getElementById("resultCV");
      const resultCTX = resultCV.getContext("2d");
      let originalData=originalCTX.getImageData(0, 0, originalCV.width,
                                                originalCV.height).data;
      let maskData=maskCTX.getImageData(0, 0, maskCV.width, maskCV.height).data;
//------------------------------------------------------------------------------
      let originalDataInGray = [];
      for(let i=0;i<(originalData.length/4);i++){ //計算灰度
        let gray=0;
        gray+=originalData[i*4+0]*0.299;
        gray+=originalData[i*4+1]*0.587;
        gray+=originalData[i*4+2]*0.114;
        originalDataInGray.push(Math.floor(gray));
      }
      let FFTdata=[];
      Fourier.transform(originalDataInGray, FFTdata);
      let maxMagnitude = 0;
      for (let i = 0; i< FFTdata.length; i++){
        let mag = FFTdata[i].magnitude();
        if (mag > maxMagnitude)
        {maxMagnitude = mag;}
      }let cc=9e-3;
      let logOfMaxMag = Math.log(cc*maxMagnitude+1);
      let dataThatPutIntoFFTcv=new Array(canvas.width * canvas.width);
      for(let i=0;i<FFTdata.length;i++){
        let color = Math.log(cc*FFTdata[i].magnitude()+1);
        color = Math.round(255*(color/logOfMaxMag));
        dataThatPutIntoFFTcv[shiftIndex(i)]=color;
      }
      putImgInto(dataThatPutIntoFFTcv,fftCV);
//------------------------------------------------------------------------------
      let maskDataInGray = [];
      for(let i=0;i<(maskData.length/4);i++){ //計算灰度
        let gray=0;
        gray+=maskData[i*4+0]*0.299;
        gray+=maskData[i*4+1]*0.587;
        gray+=maskData[i*4+2]*0.114;
        maskDataInGray.push(Math.floor(gray));
      }
      for(let i=0;i<FFTdata.length;i++){
        let thisData=FFTdata[i];
        let timeData=maskDataInGray[shiftIndex(i)]/255*(doubleMode*2);
        FFTdata[i]=thisData.times(timeData);
      }
      let ifftWithMask=[];
      Fourier.invert(FFTdata, ifftWithMask);
      putImgInto(ifftWithMask,resultCV);
    }
  </script>
</body>
</html>
